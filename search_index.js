var documenterSearchIndex = {"docs":
[{"location":"functions/","page":"Functions","title":"Functions","text":"CurrentModule = RecombTools\nDocTestSetup  = quote\n    using TreeTools\nend\t","category":"page"},{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"functions/#Computing-Maximal-Compatible-Clades-(MCCs)-for-a-set-of-trees","page":"Functions","title":"Computing Maximal Compatible Clades (MCCs) for a set of trees","text":"","category":"section"},{"location":"functions/#Main-functions","page":"Functions","title":"Main functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"computeMCCs\ncomputeMCCs!","category":"page"},{"location":"functions/#RecombTools.computeMCCs","page":"Functions","title":"RecombTools.computeMCCs","text":"computeMCCs(\n\ttrees::Dict, oa::OptArgs=OptArgs();\n\tpreresolve = false, naive = false, seqlengths = Dict(s=>1 for s in keys(trees)),\n)\ncomputeMCCs(\n\tt1::Tree, t2::Tree, oa::OptArgs = OptArgs();\n\tpreresolve = false, naive = false, seqlengths = [1,1],\n)\n\nCompute pairwise MCCs for trees. Return MCCs and resolved splits. The computeMCCs! version resolves the input trees with newly found splits.\n\nInputs\n\noa::OptArgs\n\nControls parameters of the MCC inference (unless naive=true). See ?OptArgs for details.\n\npreresolve = false\n\nIf true, a first pass of MCC computation is made and trees are resolved using the results, keeping only compatible splits if more than two trees are given as input. A second pass of MCC computation is then made without resolving.\nElse, only the first pass is performed. For more than two trees, this may find MCCs that introduce incompatible splits in case of poorly resolved input trees.\n\nIn general, this should be set to true if more than two trees are used, and to false   for only two trees (for speed).\n\nnaive = false\n\nIf true, use a naive estimation for MCCs, i.e. find all clades that have an exactly matching topology in all trees.\nElse, use a pseudo-parsimonious method based (mostly) on topology. The method runopt(oa,t1,t2) is called on every pair of trees.\n\n\n\n\n\n","category":"function"},{"location":"functions/#RecombTools.computeMCCs!","page":"Functions","title":"RecombTools.computeMCCs!","text":"computeMCCs!(\n\ttrees::Dict, oa::OptArgs=OptArgs();\n\tpreresolve = false, naive = false, seqlengths = Dict(s=>1 for s in keys(trees)),\n)\n\nSee computeMCCs.\n\n\n\n\n\n","category":"function"},{"location":"functions/#For-pairs-of-trees-only","page":"Functions","title":"For pairs of trees only","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"naive_mccs\nRecombTools.runopt","category":"page"},{"location":"functions/#RecombTools.naive_mccs","page":"Functions","title":"RecombTools.naive_mccs","text":"naive_mccs(treelist)\n\nFind sets of nodes which are:\n\nclades in all trees of treelist,\nall subclades of nodes are clades in all trees of treelist (both of these properties define consistency),\nmaximal: adding a node to a set results it in not being a clade in at least one of the trees.\n\nAll the trees of treelist should share the same leaf nodes.\n\n\n\n\n\n","category":"function"},{"location":"functions/#RecombTools.runopt","page":"Functions","title":"RecombTools.runopt","text":"\trunopt(t1::Tree, t2::Tree; kwargs...)\n\trunopt(oa::OptArgs, t1::Tree, t2::Tree)\n\trunopt(oa::OptArgs, trees::Dict{<:Any,<:Tree})\n\nRun optimization at constant γ. See ?Optargs for arguments. In the first form, keyword   arguments are given to OptArgs.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Resolving-trees","page":"Functions","title":"Resolving trees","text":"","category":"section"},{"location":"functions/#Using-topology","page":"Functions","title":"Using topology","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"resolve!(::TreeTools.Tree, ::TreeTools.Tree)","category":"page"},{"location":"functions/#RecombTools.resolve!-Tuple{TreeTools.Tree, TreeTools.Tree}","page":"Functions","title":"RecombTools.resolve!","text":"resolve!(t1::Tree, t2::Tree; tau=0.)\n\nResolve t1 using splits of t2 and inversely. Every split of t2 a tree that is compatible with t1 is introduced in t1 with branch length tau (and inversely). Return new splits in each tree.\n\n\n\n\n\n","category":"method"},{"location":"opttrees/#opttrees","page":"opttrees","title":"The opttrees function","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"The core of the heuristic RecombTools is based on happens in the opttrees function, found in the SplitGraph submodule.    Given two trees, opttrees attempts to reconcile them by pruning certain clades.    A quick description of different steps in this function is given here, with the two simple trees below as an example case: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"using RecombTools# hide\nnwk1 = \"(((A1:1,A2:2):2,(B1:2,(B2:1,B3:1):1):2):2,(C1:1,C2:2):4)\";\nnwk2 = \"((A1:1,A2:2):2,((B1:2,(B2:1,B3:1):1):1,(C1:1,C2:2):1):1)\";\nt1 = node2tree(parse_newick(nwk1))\nt2 = node2tree(parse_newick(nwk2))\nnothing # hide","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Trees are not displayed here for space reasons, but you're encouraged to draw them if you want to follow along! ","category":"page"},{"location":"opttrees/#Coarse-graining-of-naive-MCCs","page":"opttrees","title":"Coarse-graining of naive MCCs","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"As a first step, naive MCCs are computed for input trees using the naive_mccs function.    Here, we find three clades that are already compatible between the two trees: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"treelist = Any[t1, t2]\nmcc = naive_mccs(treelist)","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Trees are then \"reduced\" to those MCCs: new trees are built where each leaf corresponds to one of the naive MCCs.    The reduced trees have incompatibilities at the leaf level: it is no longer possible to group some of their leaves together in a consistent clade.  ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"mcc_names = RecombTools.name_mcc_clades!(treelist, mcc)\nfor (i,t) in enumerate(treelist)\n\ttreelist[i] = RecombTools.reduce_to_mcc(t, mcc)\nend\nnothing # hide","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"The trees in treelist are now a reduced form of t1 and t2, and the names of the new leaves correspond to clades in the original tree.    The mapping between leaf name and original clade is stored in mcc_names","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"treelist[1]\ntreelist[2]\nmcc_names","category":"page"},{"location":"opttrees/#The-SplitGraph-object","page":"opttrees","title":"The SplitGraph object","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Once the trees reduced to their naive MCCs, we construct a SplitGraph object from them. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"info: *SplitGraph* submodule\nThe SplitGraph type and some of the functions used below are in the SplitGraph submodule of RecombTools. Access them by calling using RecombTools.SplitGraph and preceding the calls by SplitGraph.","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"The SplitGraph is a directed graph that is based on both trees, and has two kind of nodes: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"leaf nodes correspond to leaves of the trees, and are identifier by integers.  They have as many ancestors as there are trees in the SplitGraph. \ninternal nodes, called SplitNodes, correspond to internal nodes in one of the two trees. A color::Int attribute identifies the tree to which they belong (e.g. 1 for the first tree, 2 for the second, etc...). They have only one ancestor, of the same color.  Importantly, they are identified by the ensemble of leaf nodes that are \"below\" them, that is the subset of all their direct and indirect offsprings that are leaves.  As such, they uniquely correspond to a split in one of the two trees.  This information is stored as an array of integer in their conf field. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Let us know build the SplitGraph object: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"using RecombTools.SplitGraph\ng = SplitGraph.trees2graph(treelist); \ng.labels_to_int","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"warning: Warning\nIt is recommemded that you add ; to the end of lines when working with SplitGraph, SplitNode or LeafNode in the REPL.  If you forget, you will quickly see why :-) ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"We now see that the three leaves from our coarse-grained trees have been attributed an integer index in the SplitGraph.    Let us take a look at the internal nodes above the leaf MCC_3: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"a1 = g.leaves[g.labels_to_int[\"MCC_3\"]].anc[1]; # Ancestor for the first tree\na2 = g.leaves[g.labels_to_int[\"MCC_3\"]].anc[2]; # Ancestor for the second tree\n[a1.color, a2.color] # a1 and a2 resp. belong to trees 1 and 2\na1.conf # list of leaves below `a1`. Among those is the index for \"MCC_3\".\n[g.labels[i] for i in a1.conf] # Same as above, with labels\n[g.labels[i] for i in a2.conf] # and the same for a2 ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"We now immediatly see that the internal nodes above MCC_3 in the two trees define different splits: (MCC_1, MCC_3) in the first tree is different from (MCC_2, MCC_3) in the second tree.    This is the idea underlying the inference of MCCs. ","category":"page"},{"location":"opttrees/#Counting-incompatibilities","page":"opttrees","title":"Counting incompatibilities","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"In the example above, the ancestors of leaf MCC_3 in the two trees define different splits: this is called an incompatibility.    Examination of the trees reveals that there are also similar incompatibilitie for the two other leaves MCC_1 and MCC_2.    This can be computed using the count_mismatches function: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"SplitGraph.count_mismatches(g)","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"We indeed find 3 mismatches, one for each leaf. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"However, it is possible to explain the two example trees using less than three reassortments.    What would happen for example if we removed MCC_1 from both trees?    The first non-trivial split above leaf MCC_3 in both trees would then be (MCC_2, MCC_3), and the same goes for leaf MCC_2.    The number of incompatibilities would then go down to 0.  \"Removing\" leaves from the trees, or the graph, is done by defining a configuration: an array of booleans that stores the presence or absence of each leaf.    To remove MCC_1, we simply design a configuration that has 0 at the index corresponding to MCC_1: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"  conf = ones(Bool, length(g.leaves))\n  conf[g.labels_to_int[\"MCC_1\"]] = false # Remove `MCC_3` from the configuration\n  conf","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"To compute the number of incompatibilities given a configuration, we use the compute_energy function. The result is interpreted as the \"energy\" of this configuration given the graph g: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"SplitGraph.compute_energy(conf, g)","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"info: Info\nThe function count_mismatches(g) shown above is a simple shortcut for conf = ones(Bool, length(g.leaves))\nSplitGraph.compute_energy(conf, g)In other words, it computes the energy for the configuration where all leaves are present. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"By removing a leaf, i.e. by \"enforcing\" a reassortment right above it, we've reduced the number of incompatibilities for the remaining ones to 0.    Since removing a leaf corresponds to \"enforcing\" a reassortment, we have to assign a cost to it, that we call gamma.    This defines a score for each configuration, defined as the difference between the energy of the configuration and gamma times the number of leaves that were removed. Depending on the value of gamma, the difference in overall score associated to removing a leaf or keeping it will change from negative to positive.    Scores are computed with the compute_F function that takes gamma as its last argument.   Here are the differences in scores before and after removing MCC_3, for different values of gamma:   ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"conf0 = ones(Bool, length(g.leaves)) # Configuration with all leaves\nSplitGraph.compute_F(conf, g, 1) - SplitGraph.compute_F(conf0, g, 1)\nSplitGraph.compute_F(conf, g, 2) - SplitGraph.compute_F(conf0, g, 2)\nSplitGraph.compute_F(conf, g, 3) - SplitGraph.compute_F(conf0, g, 3)\nSplitGraph.compute_F(conf, g, 4) - SplitGraph.compute_F(conf0, g, 4)","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"For this simple example, gamma = 3 is the \"critical\" value above which the fact of removing MCC_3 or any other leaf is not considered a good move.    The inference of MCCs for gamma leq 3 and gamma  3 will thus give different results.    In the first case, two MCCs will be found, corresponding to one reassortment event (above MCC_3 for instance) .    In the second, three MCCs and three reassortments will be found. ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"trees = Dict(1=>t1, 2=>t2);\ncomputeMCCs(trees, OptArgs(γ=3.1))[1,2]\ncomputeMCCs(trees, OptArgs(γ=2.9))[1,2]","category":"page"},{"location":"opttrees/#Simulated-annealing","page":"opttrees","title":"Simulated annealing","text":"","category":"section"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"The opttrees function attempts to find the configuration, i.e. a set of leaves to remove, that minimizes the compatibility score presented above.    Since this is a discrete optimization problem with no clear mathematical formalization, we choose to use the simulated annealing technique.  Let us find optimum configurations for our simple trees: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"Trange = reverse(1e-3:1e-2:1) # Cooling schedule\nM = 10 # Number of iterations per temperature value\nopt_confs = SplitGraph.sa_opt(g; Trange, M, γ = 2)[1]","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"We find three optimal configurations, each corresponding to removing one leaf.    This indeed corresponds to the three possible single-reassortment explanations that we could give to reconcile the two trees.    Without branch length information, it is impossible to choose between one of these three optimas: the problem is degenerate.    A likelihood based way to break this degeneracy using branch length is described here.","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"For now, let's imagine that we have chosen the first optimum configuration as our best solution.    Let's now map it back on the initial trees: ","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"removed_leaves = g.labels[.!opt_confs[1]] # Expressed with coarse grained leaves\n# `mcc_names` was defined above\nremoved_clades = [mcc_names[x] for x in removed_leaves]","category":"page"},{"location":"opttrees/","page":"opttrees","title":"opttrees","text":"What this means is that we have just inferred all elements in removed_clades (just one in our case) to be MCCs.    Of course, in this simple example, it is immediate to see that the other MCC simply consists of all the remaining leaves in the original trees.    This can also be deduced from the fact that the energy of all the optimal configurations is 0.  However, in the general case, some incompatibilities will remain even after simulated annealing.    For this reason, the opttrees function only outputs MCCs that have been identified by having removed them from the tree, i.e. by having enforced a reassortment above their root node.    If the trees that remain after having pruned these MCCs still have incompatibilities, the process described here needs to be iterated.    This is performed by the runopt function. ","category":"page"},{"location":"flu_example/#Flu-example","page":"Flu example","title":"Flu example","text":"","category":"section"},{"location":"flu_example/","page":"Flu example","title":"Flu example","text":"RecombTools includes the small submodule Flu that contains convenient functions when working with influenza trees.    To infer MCCs from a pair of influenza trees, we first use the Flu.read_flu_trees function that takes a dictionary pointing to newick files as input: ","category":"page"},{"location":"flu_example/","page":"Flu example","title":"Flu example","text":"using RecombTools\ntree_files = Dict(\n\t\"ha\" => dirname(pathof(RecombTools)) * \"/../examples/tree_h3n2_ha.nwk\",\n\t\"na\" => dirname(pathof(RecombTools)) * \"/../examples/tree_h3n2_na.nwk\"\n)\nflutrees = Flu.read_flu_trees(tree_files)","category":"page"},{"location":"flu_example/","page":"Flu example","title":"Flu example","text":"read_flu_trees does two things: ","category":"page"},{"location":"flu_example/","page":"Flu example","title":"Flu example","text":"read input trees and store them in a Dict{String, Tree}, which is the input format of computeMCCs\nremove \"short\" branches from the trees.  Some tree builders introduce branches of insignificant length in trees to make them binary, which conflicts with the topological approach used by RecombTools.  It is necessary to remove these branches.  The threshold below which a branch is removed is frac12L where L is the length of the gene sequence. ","category":"page"},{"location":"flu_example/","page":"Flu example","title":"Flu example","text":"We can now simply infer MCCs for these trees:","category":"page"},{"location":"flu_example/","page":"Flu example","title":"Flu example","text":"computeMCCs(flutrees)[\"ha\", \"na\"]","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#Handling-trees","page":"Overview","title":"Handling trees","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Functions that directly handle trees are found in the separate TreeTools package.    Here is a short list of useful ones: ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"read_tree(file): read tree from newick file. \nparse_newick(string): parse newick string into a TreeNode object\nnode2tree(n::TreeNode): create a Tree object from node n, using it as a root. \nwrite_newick(file::String, t::Tree)/write_newick([file::String], n::TreeNode): write tree to file using newick format. Return a newick string if file is not provided. ","category":"page"},{"location":"overview/#Simple-case","page":"Overview","title":"Simple case","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Let's see how to infer MCCs for a very simple case: two trees with five leaves. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using RecombTools\nt1 = node2tree(parse_newick(\"((A,B),(C,(D,X)))\"))\nt2 = node2tree(parse_newick(\"((A,(B,X)),(C,D))\"))","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The computeMCCs function takes a dictionary of trees as input.  It would normally be indexed by e.g. flu segments, but here we will simply index it with integers.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"trees = Dict(1=>t1, 2=>t2)\nmccs = computeMCCs(trees)\nmccs[1,2]","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Individual MCCs are simply arrays containing labels of leaves of the trees.  ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Note that the output of computeMCCs is a Dict, indexed by pairs of keys of the input dictionary trees. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"By convention, mccs[i,i] is always empty.","category":"page"},{"location":"overview/#Interpretation-of-results","page":"Overview","title":"Interpretation of results","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The genealogy of two RNA segments subject to reassortment is described by an Ancestral Reassortment Graph (ARG).  An ARG is a directed graph that represents the lineage of a given pair of segments by coalescence of nodes, as in a genealogical tree, but also shows reassortment events and the exchange of segments by nodes that have two ancestors.  Since reassortments only occur between segments, the genealogy of given segment is described by a tree.  As a result, the ARG must embed both segment-trees, and every branch in the ARG has to belong to either one of the trees, or to both. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"RecombTools infers the ARG by finding the branches that are common to both trees.  Given two trees with potentially different topologies, it tries to \"glue\" them together in a reasonable way, where the interpretation of reasonable can vary between parsimonious and conservative (see the parsimony parameter gamma). ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The MCCs returned by computeMCCs represent regions of the ARG (and of the segment trees) where branches are common to both trees.  In other words, these are the regions where the two segment trees must be \"glued together\".  Given those regions and the knowledge of the trees, it is possible to unambiguously reconstruct the genealogy. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"info: Number of reassortments in the genealogy\nWhen going up the ARG (backwards in time), a reassortment consists of passing from a region where branches are common to the two trees to a region where they are not. It is a split of branches.  As a consequence, the root of each MCC must be a reassortment, with the exception of an MCC containing the root of both trees.  The number of reassortments events in the inferred ARG can thus simply be obtained by counting the number of MCCs, potentially removing the one that contains the roots of both trees if it exists. ","category":"page"},{"location":"overview/#More-than-two-trees","page":"Overview","title":"More than two trees","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"If more than two trees are given as input, computeMCCs infers MCCs for all pairs of trees.  ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using RecombTools # hide\nt1 = node2tree(parse_newick(\"((A,B),((C,Y),(D,X)))\"))\nt2 = node2tree(parse_newick(\"((A,(B,X)),((C,Y),D))\"))\nt3 = node2tree(parse_newick(\"((A,(B,Y)),(C,(D,X)))\"))\ntrees = Dict(1=>t1, 2=>t2, 3=>t3)\nmccs = computeMCCs(trees)\nmccs[1,2]","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"mccs[1,3]","category":"page"},{"location":"overview/#naive_mccs","page":"Overview","title":"Naive estimation","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"It is also possible to compute a \"naive\" estimation of MCCs using the naive keyword.    When naive is set to true, computeMCCs returns maximum clades that are exactly compatible between pairs of trees: ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using RecombTools # hide\nt1 = node2tree(parse_newick(\"(((A1,A2),(B1,B2)),(C1,C2))\"))\nt2 = node2tree(parse_newick(\"(((A1,A2),(C1,C2)),(B1,B2))\"))\ntrees = Dict(1=>t1, 2=>t2)\ncomputeMCCs(trees; naive=true)","category":"page"},{"location":"options/#OptArgs-options","page":"Important options","title":"OptArgs options","text":"","category":"section"},{"location":"options/","page":"Important options","title":"Important options","text":"computeMCCs uses a topogy based heuristic optimization to find maximally compatible clades.    Options to this heuristic are provided through the OptArgs object, that is optionally passed as a second argument.   Essential options are detailed here. \t","category":"page"},{"location":"options/#gamma","page":"Important options","title":"Parsimony parameter","text":"","category":"section"},{"location":"options/","page":"Important options","title":"Important options","text":"The heuristic method used by RecombTools tries to prune consistent clades from a pair of trees in order to increase a compatibility score between other clades.    Pruning a clade is interpreted as fixing a reassortment right above it, while increasing the compatibility between remaining clades removes reassortments.    A purely parsimonious heuristic should thus give the same weight to fixing a reassortment through pruning a clade and fixing one incompatibility in the trees. ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"Here, we assign the score gamma to each pruned clade, and count as 1 each incompatibility fixed for the remaining clades.    For gamma=1, we obtain a parsimonious method that attempts to minimize the overall number of reassortments.    For higher values, pruning a clade must \"fix\" at least gamma incompatibilities to be considered a good move, making the obtained MCCs less parsimonious.    For infinite gamma, pruning clades is impossible, and we fall back on the naive estimation of MCCs. ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"The example below illustrates the difference between different gamma values: ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"using RecombTools # hide\nt1 = node2tree(parse_newick(\"((((A,B),C),D),E)\"))\nt2 = node2tree(parse_newick(\"((((D,B),E),A),C)\")) # Same topology, but shuffled leaves\ntrees = Dict(1=>t1, 2=>t2)\nnothing # hide","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"Here, pruning the two leaves (A,C) or (D,E) results in compatible trees (resp. ((B,D),E) and ((A,B),C)).    These moves each have a cost 2gamma (removing 2 clades), but bring us from trees with 5 incompatibilities to 0.    They will only be accepted if gamma leq 25. ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"  computeMCCs(trees, OptArgs(γ=2))[1,2]\n  computeMCCs(trees, OptArgs(γ=3))[1,2]","category":"page"},{"location":"options/#Resolving-trees-with-polytomies","page":"Important options","title":"Resolving trees with polytomies","text":"","category":"section"},{"location":"options/","page":"Important options","title":"Important options","text":"See Resolving","category":"page"},{"location":"options/#likelihood","page":"Important options","title":"Degeneracy: sorting with likelihood","text":"","category":"section"},{"location":"options/","page":"Important options","title":"Important options","text":"When several MCC decompositions are possible, degeneracy is removed by using the likelihood_sort option (activated by default).  In the example below, there are three equivalent decompositions if only topology is considered: ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"using RecombTools # hide\nt1 = node2tree(parse_newick(\"((A:2,B:2):2,C:4)\"))\nt2 = node2tree(parse_newick(\"(A:2,(B:1,C:1):1)\"))\ntrees = Dict(1=>t1, 2=>t2)\noa = OptArgs(likelihood_sort = false)\nunique([computeMCCs(trees, oa)[1,2] for rep in 1:50]) # Repeating computation many times ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"When taking branch lengths into account, this degeneracy vanishes: ","category":"page"},{"location":"options/","page":"Important options","title":"Important options","text":"oa = OptArgs(likelihood_sort = true)\nunique([computeMCCs(trees, oa)[1,2] for rep in 1:50])","category":"page"},{"location":"runopt/#The-runopt-function","page":"runopt","title":"The runopt function","text":"","category":"section"},{"location":"runopt/","page":"runopt","title":"runopt","text":"using RecombTools\nusing RecombTools.SplitGraph\nusing TreeTools","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"For larger trees, opttrees will not find all reassortments at once.    The reason for this is that it is often necessary to \"clean\" reassorted leaves in smaller clades in order to see other reassortments deeper in the tree.    As a consequence, trees obtained after one round of opttrees will still have incompatibilities.  Below is a relatively simple example of trees for which opttrees does not find all reassorted leaves in one go: ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"nwk1 = \"(Z,(G,(((A,X),(B,C)),((D,Y),(E,F)))))\"\nnwk2 = \"(G,((A,(B,(C,X))),((D,(E,(F,Y))),Z)))\"\nt1 = node2tree(parse_newick(nwk1))\nt2 = node2tree(parse_newick(nwk2))\nnothing # hide","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"These trees are constructed in the following way (you're encouraged to draw them!): ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"Clade ((A,X),(B,C)) in the first tree \"corresponds\" to clade (A,(B,(C,X))) in the second tree, with X as the reassorted leaf.  Same goes for clades ((D,Y),(E,F)) and (D,(E,(F,Y))). \nWe respectively name these not yet compatible clades ABC and DEF. At a deeper level, the trees are now of the form (Z,(G,(ABC,DEF))) for the first and (G,(ABC,(DEF,Z))) for the second, with Z as the obvious reassorted leaf. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"The important property here is that for a high enough value of gamma, it is only possible for opttrees to see that Z is reassorted if clades ABC and DEF are \"coarse-grained\" to leaves.    In return, this coarse-graining is only possible after X and Y have been identified as reassorted leaves, which will happen after a first iteration of opttrees.     The task of iterating opttrees is performed by the runopt function.    Here, we walk through typical steps it takes.","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"Let's do a first pass with opttrees, with gamma=3.     We first build the SplitGraph object, as detailed in the opttrees page. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"treelist = Any[t1, t2]\nmccs_naive = naive_mccs(treelist) # these are just the leaves in this example\nmcc_names = RecombTools.name_mcc_clades!(treelist, mccs_naive)\nfor (i,t) in enumerate(treelist)\n  treelist[i] = RecombTools.reduce_to_mcc(t, mccs_naive)\nend\ng = SplitGraph.trees2graph(treelist);\nnothing # hide","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"We then run the simulated annealing optimization to find optimal leaves to remove. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"opt_confs = SplitGraph.sa_opt(g; Trange = reverse(1e-3:1e-2:1), M = 10, γ = 3)[1]\nmccs_found = [mcc_names[x] for x in g.labels[.!opt_confs[1]]]","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"!!! info gamma = 2     If you run this example using gamma leq 2, Z will immediatly be found as a reassorted strain.      It is indeed not easy to find example that combine trees with a small number of leaves (9 here), obvious reassortments, and that are not solved in one go by opttrees with a low value of gamma.      However, when dealing with trees with hundreds of leaves, finding all MCCs in one go is the exception rather than the rule. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"As expected, X Y are found as reassortants.    However, the two trees will still have incompatibilities when removing those two leaves.    To make this explicit, we remove the leaves X and Y and compute naive mccs again. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"RecombTools.pruneconf!(mccs_found, treelist...) # prune clades in a list of trees. Wrapper around TreeTools.prunesutree!\nmccs_naive = naive_mccs(treelist...)","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"Now that X and Y are removed, we see that clades ABC and DEF are common to both trees.    If we reduce the pruned trees to their new naive MCCs again, we now see that Z is an obvious choice for a reassorted strain: ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"mcc_names = RecombTools.name_mcc_clades!(treelist, mccs_naive)\nfor (i,t) in enumerate(treelist)\n  treelist[i] = RecombTools.reduce_to_mcc(t, mccs_naive)\nend\ntreelist[1]\ntreelist[2]","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"To finish the inference of MCCs, we would now have to re-run the optimization process.    It is now clear that the opttrees has to be iterated.    This is performed automatically by the runopt function.    This process stops when one of the following end conditions is found: ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"If no new MCCs are found in a given iteration of opttrees.  This occurs when the optimal configuration resulting from the simulated annealing has all leaves present. \nIf not and new MCCs were found, prune them from the trees.  If the resulting trees do not have any incompatibility.\nIf not, if the maximum number of iterations has been reached.  This can be set through OptArgs, with a default of 15. ","category":"page"},{"location":"runopt/","page":"runopt","title":"runopt","text":"","category":"page"},{"location":"#RecombTools","page":"Index","title":"RecombTools","text":"","category":"section"},{"location":"#Installation","page":"Index","title":"Installation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"RecombTools relies on the non-registered julia package TreeTools, that you have to install first.    After that, simply install RecombTools from the url of this github repo: ","category":"page"},{"location":"","page":"Index","title":"Index","text":"using Pkg\nPkg.add(url=\"https://github.com/PierreBarrat/TreeTools#master\")\nPkg.add(url=\"https://github.com/PierreBarrat/RecombTools#master\")","category":"page"},{"location":"","page":"Index","title":"Index","text":"You should now be able to use using RecombTools. ","category":"page"},{"location":"","page":"Index","title":"Index","text":"Should you want to simulate ARGs (i.e. multiple trees with reassortment events), you might find it useful to get the ARGTools package: ","category":"page"},{"location":"","page":"Index","title":"Index","text":"using Pkg\nPkg.add(url=\"https://github.com/PierreBarrat/ARGTools#master\")","category":"page"},{"location":"resolving/#Resolving","page":"Resolving","title":"Resolving","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The lack of resolution in the inference of phylogenetic trees results in polytomies: internal nodes with more than two offsprings.    Polytomies can cause the topology of two trees to differ, which cause problems when inferring reassortments using topological information.    Suppose for instance that we have a first tree (e.g. for a given segment of flu): ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"using RecombTools # hide\nt1 = node2tree(parse_newick(\"(A,(B,C))\"))","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"where we can identify the clade (B,C) because of a mutation in this segment present in B and C but not in A. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"If this mutation does not exist in a second segment, then in the absence of reassortment its tree will look something like this: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"t2 = node2tree(parse_newick(\"(A,B,C)\"))","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"As a result, t1 and t2 differ for a reason unrelated with reassortment. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"To overcome this issue, one has to resolve trees as much as possible, typically using the information of one to remove polytomies in the other.    This can only be done if no reassortments are present. ","category":"page"},{"location":"resolving/#Resolving-pairs-of-trees","page":"Resolving","title":"Resolving pairs of trees","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"In the example above, it is natural to think that the difference between the two trees is due to a lack of resolution and not to reassortment.    This is because the split (B,C) in the first tree is compatible with the second tree: it is possible to add this split to t2.    What this means is that the difference in topology can be explained by something else than reassortment. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"In this case, we can simply resolve t2 by adding each split in t1 with which it is compatible.    If t1 has polytomies, the same could be done to resolve t1 using t2.    This operation is performed by the resolve! function: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"using RecombTools\nt1 = node2tree(parse_newick(\"(A,(B,C))\"))\nt2 = node2tree(parse_newick(\"(A,B,C)\"))","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"new_splits = resolve!(t1, t2);\nt2","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"resolve! returns an array of SplitList objects (of the TreeTools package) containing the new splits introduced in each of the two trees: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"isempty(new_splits[1])\nnew_splits[2]","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"If the resolve option is passed to computeMCCs (through OptArgs), resolve! will be called on each pair of trees before each iteration of the MCC inference procedure. ","category":"page"},{"location":"resolving/#Resolving-during-MCC-inference","page":"Resolving","title":"Resolving during MCC inference","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The above resolving method works fine for simple \"obvious\" cases, where a split in one tree directly resolves a polytomy in another.  However, consider the following case: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"using RecombTools","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"t1 = node2tree(parse_newick(\"((A,B),(C,(D,(E,X))))\"))\nt2 = node2tree(parse_newick(\"((A,(B,X)),(C,D,E))\"))","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"There are now two sources of topological differences between t1 and t2: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The reassorted strain X. \nThe lack of resolution resulted in a polytomy (C,D,E) in t2, which is resolved in t1 in the form of (C,(D,(E,X)) ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The resolve! function is helpless in such cases: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"new_splits = resolve!(t1, t2)\nisempty(new_splits[2])","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"Indeed, there is no split in t1 that can directly help us resolve t2.    The closest such split is (D,E,X), but it is incompatible with t2 because of X.    If we knew beforehand that X is reassorted, we could simply ignore it while resolving t2.    The (D,E,X) split in t1 would become (D,E), which is compatible with t2, and the resolve! function would handle this.  ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"However, the topology-based heuristic used by RecombTools is not able to detect that X is the only reassorted leaf if the trees are not resolved!   Indeed, if we \"remove\" X from the trees, some incompatibilities will remain.    For instance, the split above E will be (D,E) in the first tree and (C,D,E) in the second.    Without resolving, the heuristic will predict a reassortment above almost every leaf: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"computeMCCs(Dict(1 => t1, 2 => t2), OptArgs(;resolve=false))[1,2]","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"In order to achieve progress in this kind of situation, we have to perform two operations at the same time: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"realize that X is the only reassorted strain, and can be ignored when resolving.\nresolve t2 with the (D,E,X) split, ignoring X. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"This is done automatically during MCC inference if the resolve option of OptArgs is given (default):  ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"computeMCCs(Dict(1 => t1, 2 => t2), OptArgs(;resolve=true))[1,2]","category":"page"},{"location":"resolving/#Pre-resolving-for-more-than-two-trees","page":"Resolving","title":"Pre-resolving for more than two trees","text":"","category":"section"},{"location":"resolving/#Resolving-with-inferred-MCCs","page":"Resolving","title":"Resolving with inferred MCCs","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"Would it be useful to have a function that takes in MCCs and un-resolved trees, and outputs resolved trees?  ","category":"page"},{"location":"types/","page":"OptArgs","title":"OptArgs","text":"CurrentModule = RecombTools","category":"page"},{"location":"types/#The-OptArgs-object","page":"OptArgs","title":"The OptArgs object","text":"","category":"section"},{"location":"types/","page":"OptArgs","title":"OptArgs","text":"computeMCCs and several other functions take an OptArgs object that controls several parameters of the inference process. ","category":"page"},{"location":"types/","page":"OptArgs","title":"OptArgs","text":"OptArgs","category":"page"},{"location":"types/#RecombTools.OptArgs","page":"OptArgs","title":"RecombTools.OptArgs","text":"struct OptArgs\n\nStoring parameters for SplitGraph.runopt function.\n\nGeneral\n\nγ::Real = 2\nitmax::Int64 = 15: maximal number of iterations of naive MCCs / SA cycles.\nlikelihood_sort::Bool = true: sort equivalent configurations using likelihood test based on branch length.\nresolve::Bool = true: try to resolve trees while finding MCCs.\nseq_lengths: lengths of sequences that trees were built from. Used in likelihood calculations. This is initialized from other input arguments, and defaults to sequences of length one.\n\nSimulated annealing\n\nMd::Real = 10:  number of SA iterations (per temperature) for a tree of n leaves is ceil(Int, n/Md).\ncooling_schedule = :geometric: type of cooling schedule (:geometric, :linear)\nTmin::Float64 = 1e-3: minimal temperature of SA.\nTmax::Float64 = 1: maximal temperature of SA.\nαT::Float64 = 0.95: ratio between terms in the geometric cooling.\ndT::Float64 = 1e-2: temperature step in the linear cooling.\n\nVerbosity\n\nverbose::Bool=false: first level of verbosity\nvv::Bool = false: second level of verbosity\n\nOutput\n\noutput = :mccs: possible values [:mccs, :mccs_df, :all]. If calling computeMCCs, this should always be set to :mccs. Other values are only relevant when calling runopt.\n\n\n\n\n\n","category":"type"}]
}
