var documenterSearchIndex = {"docs":
[{"location":"functions/","page":"Functions","title":"Functions","text":"CurrentModule = RecombTools\nDocTestSetup  = quote\n    using TreeTools\nend\t","category":"page"},{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"functions/#Computing-Maximal-Compatible-Clades-(MCCs)-for-a-set-of-trees","page":"Functions","title":"Computing Maximal Compatible Clades (MCCs) for a set of trees","text":"","category":"section"},{"location":"functions/#Main-functions","page":"Functions","title":"Main functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"computeMCCs\ncomputeMCCs!","category":"page"},{"location":"functions/#RecombTools.computeMCCs","page":"Functions","title":"RecombTools.computeMCCs","text":"computeMCCs(\n\ttrees::Dict{<:Any, <:Tree}, oa::OptArgs=OptArgs();\n\tpreresolve=true, naive=false\n)\n\nCompute pairwise MCCs for trees. Return MCCs and resolved splits. The computeMCCs! version resolved the input trees with newly found splits.\n\nInputs\n\noa::OptArgs\n\nControls parameters of the MCC inference (unless naive=true). See ?OptArgs for details.\n\npreresolve = true\n\nIf true, a first pass of MCC computation is made and trees are resolved using the results, keeping only compatible splits if more than two trees are given as input. A second pass of MCC computation is then made without resolving.\nElse, only the first pass is performed. For more than two trees, this may find MCCs that introduce incompatible splits in case of poorly resolved input trees.\n\nnaive = false\n\nIf true, use a naive estimation for MCCs, i.e. find all clades that have an exactly matching topology in all trees.\nElse, use a pseudo-parsimonious method based (mostly) on topology. The method runopt(oa,t1,t2) is called on every pair of trees. by calling function runopt(oa,t1,t2) on pairs of trees. Return MCCs and resolved splits.\n\noutput = :mccs\n\nControl the type of output. If :mccs, only MCCs are returned. If :all, splits added \tin trees during the inference process are returned as well.\n\n\n\n\n\n","category":"function"},{"location":"functions/#RecombTools.computeMCCs!","page":"Functions","title":"RecombTools.computeMCCs!","text":"computeMCCs!(\n\ttrees::Dict{<:Any, <:Tree}, oa::OptArgs=OptArgs();\n\tpreresolve = true, naive = false, output = :mccs\n)\n\nSee computeMCCs.\n\n\n\n\n\n","category":"function"},{"location":"functions/#For-pairs-of-trees-only","page":"Functions","title":"For pairs of trees only","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"naive_mccs\nRecombTools.runopt","category":"page"},{"location":"functions/#RecombTools.naive_mccs","page":"Functions","title":"RecombTools.naive_mccs","text":"naive_mccs(treelist)\n\nFind sets of nodes which are:\n\nclades in all trees of treelist,\nall subclades of nodes are clades in all trees of treelist (both of these properties define consistency),\nmaximal: adding a node to a set results it in not being a clade in at least one of the trees.\n\nAll the trees of treelist should share the same leaf nodes.\n\n\n\n\n\n","category":"function"},{"location":"functions/#RecombTools.runopt","page":"Functions","title":"RecombTools.runopt","text":"\trunopt(t1::Tree, t2::Tree; kwargs...)\n\trunopt(oa::OptArgs, t1::Tree, t2::Tree)\n\trunopt(oa::OptArgs, trees::Dict{<:Any,<:Tree})\n\nRun optimization at constant γ. See ?Optargs for arguments. In the first form, keyword   arguments are given to OptArgs.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Resolving-trees","page":"Functions","title":"Resolving trees","text":"","category":"section"},{"location":"functions/#Using-topology","page":"Functions","title":"Using topology","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"resolve!(::TreeTools.Tree, ::TreeTools.Tree)","category":"page"},{"location":"functions/#RecombTools.resolve!-Tuple{TreeTools.Tree, TreeTools.Tree}","page":"Functions","title":"RecombTools.resolve!","text":"resolve!(t1::Tree, t2::Tree; tau=0.)\n\nResolve t1 using splits of t2 and inversely. Every split of t2 a tree that is compatible with t1 is introduced in t1 with branch length tau (and inversely). Return new splits in each tree.\n\n\n\n\n\n","category":"method"},{"location":"usage/#Overview","page":"Usage","title":"Overview","text":"","category":"section"},{"location":"usage/#Simple-case","page":"Usage","title":"Simple case","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Let's see how to infer MCCs for a very simple case: two trees with five leaves. ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using RecombTools, TreeTools\nt1 = node2tree(parse_newick(\"((A,B),(C,(D,X)))\"))\nt2 = node2tree(parse_newick(\"((A,(B,X)),(C,D))\"))","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The computeMCCs function takes a dictionary of trees as input.  It would normally be indexed by e.g. flu segments, but here we will simply index it with integers.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"trees = Dict(1=>t1, 2=>t2)\nmccs = computeMCCs(trees)\nmccs[1,2]","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Individual MCCs are simply arrays containing labels of leaves of the trees.  ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Note that the output of computeMCCs is a Dict, indexed by pairs of keys of the input dictionary trees. ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"By convention, mccs[i,i] is always empty.","category":"page"},{"location":"usage/#More-than-two-trees","page":"Usage","title":"More than two trees","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"If more than two trees are given as input, computeMCCs infers MCCs for all pairs of trees.  ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using RecombTools, TreeTools # hide\nt1 = node2tree(parse_newick(\"((A,B),((C,Y),(D,X)))\"))\nt2 = node2tree(parse_newick(\"((A,(B,X)),((C,Y),D))\"))\nt3 = node2tree(parse_newick(\"((A,(B,Y)),(C,(D,X)))\"))\ntrees = Dict(1=>t1, 2=>t2, 3=>t3)\nmccs = computeMCCs(trees)\nmccs[1,2]","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"mccs[1,3]","category":"page"},{"location":"usage/#Important-options","page":"Usage","title":"Important options","text":"","category":"section"},{"location":"usage/#Degeneracy:-sorting-with-likelihood","page":"Usage","title":"Degeneracy: sorting with likelihood","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"When several MCC decompositions are possible, degeneracy is removed by using the likelihood_sort option (activated by default).  In the example below, there are three equivalent decompositions if only topology is considered: ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using RecombTools, TreeTools # hide\nt1 = node2tree(parse_newick(\"((A:2,B:2):2,C:4)\"))\nt2 = node2tree(parse_newick(\"(A:2,(B:1,C:1):1)\"))\ntrees = Dict(1=>t1, 2=>t2)\noa = OptArgs(likelihood_sort = false)\nunique([computeMCCs(trees, oa)[1,2] for rep in 1:10])","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"When taking branch lengths into account, this degeneracy vanishes: ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"oa = OptArgs(likelihood_sort = true)\nunique([computeMCCs(trees, oa)[1,2] for rep in 1:10])","category":"page"},{"location":"resolving/#Resolving","page":"Resolving","title":"Resolving","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The lack of resolution in the inference of phylogenetic trees results in polytomies: internal nodes with more than two offsprings.    Polytomies can cause the topology of two trees to differ, which cause problems when inferring reassortments using topological information.    Suppose for instance that we have a first tree (e.g. for a given segment of flu): ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"using TreeTools, RecombTools # hide\nt1 = node2tree(parse_newick(\"(A,(B,C))\"))","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"where we can identify the clade (B,C) because of a mutation in this segment present in B and C but not in A. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"If this mutation does not exist in a second segment, then in the absence of reassortment its tree will look something like this: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"t2 = node2tree(parse_newick(\"(A,B,C)\"))","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"As a result, t1 and t2 differ for a reason unrelated with reassortment. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"To overcome this issue, one has to resolve trees as much as possible, typically using the information of one to remove polytomies in the other.    This can only be done if no reassortments are present. ","category":"page"},{"location":"resolving/#Resolving-pairs-of-trees","page":"Resolving","title":"Resolving pairs of trees","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"In the example above, it is natural to think that the difference between the two trees is due to a lack of resolution and not to reassortment.    This is because the split (B,C) in the first tree is compatible with the second tree: it is possible to add this split to t2.    What this means is that the difference in topology can be explained by something else than reassortment. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"In this case, we can simply resolve t2 by adding each split in t1 with which it is compatible.    If t1 has polytomies, the same could be done to resolve t1 using t2.    This operation is performed by the resolve! function: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"using TreeTools, RecombTools\nt1 = node2tree(parse_newick(\"(A,(B,C))\"))\nt2 = node2tree(parse_newick(\"(A,B,C)\"))","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"new_splits = resolve!(t1, t2);\nt2","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"resolve! returns an array of TreeTools.SplitList objects containing the new splits introduced in each of the two trees: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"isnothing(new_splits[1])\nnew_splits[2]","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"If the resolve option is passed to computeMCCs (through OptArgs), resolve! will be called on each pair of trees before each iteration of the MCC inference procedure. ","category":"page"},{"location":"resolving/#Resolving-during-MCC-inference","page":"Resolving","title":"Resolving during MCC inference","text":"","category":"section"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The above resolving method works fine for simple \"obvious\" cases, where a split in one tree directly resolves a polytomy in another.  However, consider the following case: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"using RecombTools, TreeTools","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"t1 = node2tree(parse_newick(\"((A,B),(C,(D,(E,X))))\"))\nt2 = node2tree(parse_newick(\"((A,(B,X)),(C,D,E))\"))","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"There are now two sources of topological differences between t1 and t2: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The reassorted strain X. \nThe lack of resolution resulted in a polytomy (C,D,E) in t2, which is resolved in t1 in the form of (C,(D,(E,X)) ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"The resolve! function is helpless in such cases: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"new_splits = resolve!(t1, t2)\nisnothing(new_splits[2])","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"Indeed, there is no split in t1 that can directly help us resolve t2.    The closest such split is (D,E,X), but it is incompatible with t2 because of X.    If we knew beforehand that X is reassorted, we could simply ignore it while resolving t2.    The (D,E,X) split in t1 would become (D,E, which is compatible with t2, and the resolve! function would handle this.  ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"In order to achieve progress in this kind of situation, we have to perform two operations at the same time: ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"realize that X is a reassorted strain, and can be ignored when resolving\nresolve t2 with the (D,E,X) split, ignoring X. ","category":"page"},{"location":"resolving/","page":"Resolving","title":"Resolving","text":"This is done automatically during MCC inference if the resolve option of OptArgs is given. ","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"CurrentModule = RecombTools\nDocTestSetup  = quote\n    using TreeTools\nend\t","category":"page"},{"location":"types/#The-OptArgs-object","page":"Types","title":"The OptArgs object","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"computeMCCs and several other functions take an OptArgs object that controls several parameters of the inference process. ","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"OptArgs","category":"page"},{"location":"types/#RecombTools.OptArgs","page":"Types","title":"RecombTools.OptArgs","text":"struct OptArgs\n\nStoring parameters for SplitGraph.runopt function.\n\nGeneral\n\nγ::Real = 3\nitmax::Int64 = 15: Maximal number of iterations of MCC / SA cycles\nlikelihood_sort::Bool = true: sort equivalent configurations using likelihood test (based on branch length for now).\nresolve::Bool = true: try to resolve trees while finding MCCs.\nseq_lengths = ones(Int64, 2): lengths of sequences that trees were built from\ncrossmap_resolve::Bool = false: Use cross-mapped mutations to resolve polytomies in the tree.  Require each leaf's data to have :selfseq and :cmseq entries.\ncrossmap_prune::Bool = false: Use cross-mappped mutations to prune MCCs preventively. The code will look at the number of suspicious mutations at n.data.dat[:suspicious_muts][s] where n = trees[s] (s is assumed to be an influenza segment). Require each leaf's data to have :selfseq and :cmseq entries.\nsuspmut_threshold::Int = 1: Minimal number of suspicious mutation to prune a branch.\n\nSimulated annealing\n\nMd::Real = 10:  Number of SA iterations (per temperature) for a tree of n leaves is ceil(Int64, n/Md)\nTmin::Float64 = 1e-3: Minimal temperature of SA\nTmax::Float64 = 1: Maximal temperature of SA\ndT::Float64 = 1e-2: Temperature step\n\nVerbosity\n\nverbose::Bool=false: first level of verbosity\nvv::Bool = false: second level of verbosity\n\nOutput\n\noutput = :mccs: possible values [:mccs, :mccs_df, :all]\n\n\n\n\n\n","category":"type"}]
}
