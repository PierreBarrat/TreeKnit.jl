<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Resolving · TreeKnit documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TreeKnit documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../mccs/">MCCs</a></li><li><a class="tocitem" href="../options/">Important options</a></li><li><a class="tocitem" href="../multitreeknit/">MultiTreeKnit</a></li><li><a class="tocitem" href="../visualization/">Visualizing MCCs</a></li></ul></li><li><span class="tocitem">Under the hood</span><ul><li><a class="tocitem" href="../opttrees/"><code>opttrees</code></a></li><li><a class="tocitem" href="../runopt/"><code>runopt</code></a></li><li class="is-active"><a class="tocitem" href>Resolving</a><ul class="internal"><li><a class="tocitem" href="#Resolving-trees"><span>Resolving trees</span></a></li><li><a class="tocitem" href="#Resolving-during-MCC-inference-for-tree-pairs"><span>Resolving during MCC inference for tree pairs</span></a></li><li><a class="tocitem" href="#Resolving-with-inferred-MCCs-for-tree-pairs"><span>Resolving with inferred MCCs for tree pairs</span></a></li><li><a class="tocitem" href="#resolve_strict_vs_liberal"><span>Strict vs liberal resolve</span></a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../types/">Objects</a></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Under the hood</a></li><li class="is-active"><a href>Resolving</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Resolving</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PierreBarrat/TreeKnit.jl/blob/master/docs/src/resolving.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="resolving"><a class="docs-heading-anchor" href="#resolving">Resolving</a><a id="resolving-1"></a><a class="docs-heading-anchor-permalink" href="#resolving" title="Permalink"></a></h1><p>The lack of resolution in the inference of phylogenetic trees results in <em>polytomies</em>: internal nodes with more than two offsprings.    Polytomies can cause the topology of two trees to differ, which cause problems when inferring reassortments using topological information.    Suppose for instance that we have a first tree (<em>e.g.</em> for a given segment of flu): </p><pre><code class="language-julia hljs">t1 = parse_newick_string(&quot;(A,(B,C));&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
 not all branch lengths known, assuming identical branch lengths

  ______________________________________ A
_|
 |                                      ______________________________________ B
 |_____________________________________|
                                       |______________________________________ C
</code></pre><p>where we can identify the clade <code>(B,C)</code> because of a mutation in this segment present in <code>B</code> and <code>C</code> but not in <code>A</code>. </p><p>If this mutation does not exist in a second segment, then in the absence of reassortment its tree will look something like this: </p><pre><code class="language-julia hljs">t2 = parse_newick_string(&quot;(A,B,C);&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
 not all branch lengths known, assuming identical branch lengths

  ____________________________________________________________________________ A
 |
_|____________________________________________________________________________ B
 |
 |____________________________________________________________________________ C
</code></pre><p>As a result, <code>t1</code> and <code>t2</code> differ for a reason unrelated with reassortment. </p><p>To overcome this issue, one has to <strong>resolve</strong> trees as much as possible, typically using the information of one to remove polytomies in the other.    This can only be done if no reassortments are present. </p><h2 id="Resolving-trees"><a class="docs-heading-anchor" href="#Resolving-trees">Resolving trees</a><a id="Resolving-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Resolving-trees" title="Permalink"></a></h2><p>In the example above, it is natural to think that the difference between the two trees is due to a lack of resolution and not to reassortment.    This is because the split <code>(B,C)</code> in the first tree is <strong>compatible</strong> with the second tree: it is possible to add this split to <code>t2</code>.    What this means is that the difference in topology can be explained by something other than reassortment. </p><p>In this case, we can simply resolve <code>t2</code> by adding each split in <code>t1</code> to <code>t2</code> with which <code>t2</code> is compatible.    If <code>t1</code> has polytomies, the same could be done to resolve <code>t1</code> using <code>t2</code>.    This operation is performed by the <code>resolve!</code> function: </p><pre><code class="language-julia hljs">new_splits = resolve!(t1, t2);
t2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
 not all branch lengths known, assuming identical branch lengths

  ______________________________________ A
_|
 |                                      ______________________________________ B
 |_____________________________________|
                                       |______________________________________ C
</code></pre><p><code>resolve!</code> returns an array of <code>SplitList</code> objects (of the <em>TreeTools</em> package) containing the new splits introduced in each of the two trees: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; isempty(new_splits[1])</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; new_splits[2]</code><code class="nohighlight hljs ansi" style="display:block;">[&quot;B&quot;, &quot;C&quot;]</code></pre><p>The <code>resolve!</code> function can also be called on more than three trees. When called on more than 2 trees it will only introduce splits from one tree into another tree if that split is compatible with <strong>all</strong> other trees. Take the same 2 trees from before (<code>t1</code> and <code>t2</code>) and assume we add a third tree <code>t3</code></p><pre><code class="language-julia hljs">t3 = parse_newick_string(&quot;(A,B,C);&quot;)
new_splits = resolve!(t1, t2, t3);
t2
t3</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
 not all branch lengths known, assuming identical branch lengths

  ______________________________________ A
_|
 |                                      ______________________________________ B
 |_____________________________________|
                                       |______________________________________ C
</code></pre><p>As the <code>(B,C)</code> split is compatible with both the 2nd and the 3rd tree it will be introduced in both trees. Now assume we add a 4th tree where the <code>(B,C)</code> split is no longer compatible. Now neither tree <code>t2</code> or <code>t3</code> will be further resolved.</p><pre><code class="language-julia hljs">new_splits = resolve!(t1, t2, t3, t4);
t2
t3</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
 not all branch lengths known, assuming identical branch lengths

  ____________________________________________________________________________ A
 |
_|____________________________________________________________________________ B
 |
 |____________________________________________________________________________ C
</code></pre><h2 id="Resolving-during-MCC-inference-for-tree-pairs"><a class="docs-heading-anchor" href="#Resolving-during-MCC-inference-for-tree-pairs">Resolving during MCC inference for tree pairs</a><a id="Resolving-during-MCC-inference-for-tree-pairs-1"></a><a class="docs-heading-anchor-permalink" href="#Resolving-during-MCC-inference-for-tree-pairs" title="Permalink"></a></h2><p>The above resolving method works fine for simple &quot;obvious&quot; cases, where a split in one tree directly resolves a polytomy in another.  However, consider the following case: </p><pre><code class="language-julia hljs">t1 = parse_newick_string(&quot;((A,B),(C,(D,(E,X))));&quot;; label=&quot;t1&quot;)
t2 = parse_newick_string(&quot;((A,(B,X)),(C,D,E));&quot;; label=&quot;t2&quot;)</code></pre><p>There are now two sources of topological differences between <code>t1</code> and <code>t2</code>: </p><ul><li>The reassorted strain <code>X</code>. </li><li>The lack of resolution resulted in a polytomy <code>(C,D,E)</code> in <code>t2</code>, which is resolved in <code>t1</code> in the form of <code>(C,(D,(E,X))</code> </li></ul><p>The <code>resolve!</code> function is helpless in such cases: </p><pre><code class="language-julia hljs">new_splits = resolve!(t1, t2)
isempty(new_splits[2])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Indeed, there is no split in <code>t1</code> that can directly help us resolve <code>t2</code>.    The closest such split is <code>(D,E,X)</code>, but it is incompatible with <code>t2</code> because of <code>X</code>.    If we knew beforehand that <code>X</code> is reassorted, we could simply ignore it while resolving <code>t2</code>.    The <code>(D,E,X)</code> split in <code>t1</code> would become <code>(D,E)</code>, which is compatible with <code>t2</code>, and the <code>resolve!</code> function would handle this.  </p><p>However, the topology-based heuristic used by <em>TreeKnit</em> is not able to detect that <code>X</code> is the only reassorted leaf <em>if the trees are not resolved</em>!   Indeed, if we &quot;remove&quot; <code>X</code> from the trees, some incompatibilities will remain.    For instance, the split above <code>E</code> will be <code>(D,E)</code> in the first tree and <code>(C,D,E)</code> in the second.    Without resolving, the heuristic will predict a reassortment above almost every leaf: </p><pre><code class="language-julia hljs">run_treeknit!(t1, t2, OptArgs(;resolve=false))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MCC_set(2, [&quot;t1&quot;, &quot;t2&quot;], Dict{Set{String}, Vector{Vector{String}}}(Set([&quot;t2&quot;, &quot;t1&quot;]) =&gt; [[&quot;C&quot;], [&quot;X&quot;], [&quot;A&quot;, &quot;B&quot;, &quot;D&quot;, &quot;E&quot;]]))</code></pre><p>In order to achieve progress in this kind of situation, we have to perform two operations at the same time: </p><ul><li>realize that <code>X</code> is the only reassorted strain, and can be ignored when resolving.</li><li>resolve <code>t2</code> with the <code>(D,E,X)</code> split, ignoring <code>X</code>. </li></ul><p>This is done automatically during MCC inference if the <code>resolve</code> option of <code>OptArgs</code> is given (default):  </p><pre><code class="language-julia hljs">MCCs = run_treeknit!(t1, t2, OptArgs(;resolve=true))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MCC_set(2, [&quot;t1&quot;, &quot;t2&quot;], Dict{Set{String}, Vector{Vector{String}}}(Set([&quot;t2&quot;, &quot;t1&quot;]) =&gt; [[&quot;X&quot;], [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;]]))</code></pre><h2 id="Resolving-with-inferred-MCCs-for-tree-pairs"><a class="docs-heading-anchor" href="#Resolving-with-inferred-MCCs-for-tree-pairs">Resolving with inferred MCCs for tree pairs</a><a id="Resolving-with-inferred-MCCs-for-tree-pairs-1"></a><a class="docs-heading-anchor-permalink" href="#Resolving-with-inferred-MCCs-for-tree-pairs" title="Permalink"></a></h2><p>Once the MCCs are inferred, it is possible to use them to resolve trees: in the regions of shared branches of the ARG, the two trees <code>t1</code> and <code>t2</code> must have the same splits.    The <code>resolve!</code> function also has a method for this.    Using the example above, we have</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t1 = parse_newick_string(&quot;((A,B),(C,(D,(E,X))));&quot;; label=&quot;t1&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t2 = parse_newick_string(&quot;((A,(B,X)),(C,D,E));&quot;; label=&quot;t2&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; resolved_splits = resolve!(t1, t2, MCCs.mccs[Set([&quot;t1&quot;, &quot;t2&quot;])]; strict=true)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{TreeTools.SplitList{String}}:

 [&quot;D&quot;, &quot;E&quot;]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t2</code><code class="nohighlight hljs ansi" style="display:block;">
 not all branch lengths known, assuming identical branch lengths

                           _________________________ A
  ________________________|
 |                        |                         _________________________ B
 |                        |________________________|
_|                                                 |_________________________ X
 |
 |                         _________________________ C
 |________________________|
                          |                         _________________________ D
                          |________________________|
                                                   |_________________________ E</code></pre><p>The split <code>(D,E)</code> is now present in <code>t2</code>.  Note that it was not present in <code>t1</code>: only the splits <code>(D,E,X)</code> and <code>(E,X)</code> existed there.  However, since <code>resolve!</code> now knows <code>(A,B,C,D,E)</code> is an MCC, the <code>resolve!</code> function can &quot;ignore&quot; leaf <code>X</code> when resolving.   </p><h2 id="resolve_strict_vs_liberal"><a class="docs-heading-anchor" href="#resolve_strict_vs_liberal">Strict vs liberal resolve</a><a id="resolve_strict_vs_liberal-1"></a><a class="docs-heading-anchor-permalink" href="#resolve_strict_vs_liberal" title="Permalink"></a></h2><p>When resolving using MCCs, TreeKnit uses one of two options: strict (default) or liberal resolution (<code>--liberal-resolve</code> flag).  Given two trees <code>t1</code> and <code>t2</code> and their MCCs, it is not always possible to unambiguously resolve <code>t2</code> using the splits of <code>t1</code> <em>even</em> in an MCC.  To explain this, we consider the two following trees: </p><pre><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t1 = parse_newick_string(&quot;((A,(B,C)),D);&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">
 not all branch lengths known, assuming identical branch lengths

                           __________________________ A
  ________________________|
 |                        |                          _________________________ B
_|                        |_________________________|
 |                                                  |_________________________ C
 |
 |_________________________ D</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t2 = parse_newick_string(&quot;(A,B,C,D);&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">
 not all branch lengths known, assuming identical branch lengths

  ____________________________________________________________________________ A
 |
 |____________________________________________________________________________ B
_|
 |____________________________________________________________________________ C
 |
 |____________________________________________________________________________ D</code></pre><p>Assume that the MCCs are <code>[A,B,C]</code> and <code>[D]</code>. In this minimal example this is a bit contrived, but this type of situation can take place in larger  trees.  The essential ingredients here are </p><ul><li>the polytomy <code>(A,B,C,D)</code> in <code>t2</code>. </li><li>the fact that the <code>(A,(B,C))</code> clade is nicely resolved in <code>t1</code></li><li><code>(A,B,C)</code>, <code>D</code>, and the other nodes being in different MCCs, meaning there is a reassortment above leaf <code>D</code> and above the MRCA of <code>(A,B,C)</code></li></ul><p>At first sight, we would like to introduce the splits <code>(A,B,C)</code> and <code>(B,C)</code> into <code>t2</code>: these splits exist in <code>t1</code> and are in the shared region <code>(A,B,C)</code>.  This would result in the following for <code>t2</code>: </p><pre><code class="language-julia hljs">t2_resolved_1 = parse_newick_string(&quot;((A,(B,C)),D);&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
 not all branch lengths known, assuming identical branch lengths

                           __________________________ A
  ________________________|
 |                        |                          _________________________ B
_|                        |_________________________|
 |                                                  |_________________________ C
 |
 |_________________________ D
</code></pre><p>However, since there is a reassortment above <code>D</code>, we cannot exclude <code>D</code> being nested in the <code>(A,B,C)</code> clade  This gives us other possibilities for <code>t2</code> (non-exhaustive):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t2_resolved_2 = parse_newick_string(&quot;(A,(B,(C,D)));&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">
 not all branch lengths known, assuming identical branch lengths

  _________________________ A
_|
 |                         __________________________ B
 |________________________|
                          |                          _________________________ C
                          |_________________________|
                                                    |_________________________ D</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t2_resolved_3 = parse_newick_string(&quot;(A,((B,C),D));&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">
 not all branch lengths known, assuming identical branch lengths

  _________________________ A
 |
_|                                                   _________________________ B
 |                         _________________________|
 |________________________|                         |_________________________ C
                          |
                          |__________________________ D</code></pre><p>All the above possibilities to resolve <code>t2</code> are compatible with the found MCCs and the splits in <code>t1</code>. </p><p>The <code>strict</code> and <code>liberal</code> options for resolution make different choices in this situation. </p><ul><li>Strict resolve will consider this situation as ambiguous, and not attempt any resolution. Hence the final <code>t2</code> will have a Newick string <code>&quot;(A,B,C,D);&quot;</code>.  More generally, with the <code>strict</code> option, TreeKnit will only resolve a polytomy if the relation of all branches within the polytomy can be unambiguously determined using the other tree, potentially not fully resolving shared regions of the trees. </li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; MCCs = [[&quot;D&quot;], [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Vector{String}}:
 [&quot;D&quot;]
 [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; new_splits_strict = resolve!(t1, t2, MCCs; strict=true);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isempty(new_splits_strict[2])</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t2</code><code class="nohighlight hljs ansi" style="display:block;">
 not all branch lengths known, assuming identical branch lengths

  ____________________________________________________________________________ A
 |
 |____________________________________________________________________________ B
_|
 |____________________________________________________________________________ C
 |
 |____________________________________________________________________________ D</code></pre><ul><li>Liberal resolve will resolve trees as much as possible, fully resolving shared regions of the two trees, but arbitrarily choosing the location of these aforementioned branches, leading to potentially wrong splits.  As in the example below, liberal resolve will always try to &quot;pull&quot; MCCs out of polytomies </li></ul><pre><code class="language-julia hljs">new_splits_liberal = resolve!(t1, t2, MCCs; strict=false);
new_splits_liberal[2]
t2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
 not all branch lengths known, assuming identical branch lengths

  _________________________ D
_|
 |                         __________________________ A
 |________________________|
                          |                          _________________________ B
                          |_________________________|
                                                    |_________________________ C
</code></pre><p>Here are a few extra notes on strict vs liberal options: </p><ul><li>liberal resolve will in general result in significantly more wrong splits placed in the trees</li><li>to create an ARG, it is necessary that MCCs are resolved exactly the same in both trees: the trees must be <em>knitted</em> together in those regions.  For this reason, it is also necessary to use liberal resolve for ARG reconstruction. </li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../runopt/">« <code>runopt</code></a><a class="docs-footer-nextpage" href="../types/">Objects »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 26 January 2023 13:45">Thursday 26 January 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
